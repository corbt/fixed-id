const { MerkleTree } = require("merkletreejs");
const { initialize } = require("zokrates-js/node");
const range = require("lodash/range");
const fs = require("fs");
const path = require("path");
const poseidon = require("circomlib/src/poseidon");
const { toBufferBE, toBigIntBE } = require("bigint-buffer");
const { PublicKey, PrivateKey } = require("babyjubjub");

require("console-stamp")(console, { format: ":date(HH:MM:ss.l)" });

// Example inputs

// The ID of the app that we'll be provide a proof to
const APP_ID = "https://www.startupschool.org";

// In practice this should be randomly generated by the app as part of each
// authentication request.
const NONCE = 12345;

// The number of private aliases that the app allows for each user. `1` means
// each user can only create one account.
const MAX_ALIASES = 1;

// The FixedID of the authenticating user.
const FIXED_ID = 1318;

// The user's immutable "password". If a user has to change their private key,
// they can recover access to FixedID authenticated accounts as long as they
// remember their password. An app that learns a user's password may be able to
// de-anonymize them (but still cannot impersonate them).
const PASSWORD = "moloch";

// Keypair on BabyJubJub to prove ownership. Ideally, the private key would be derived from the user's wallet's private key so they don't have to keep track of another secret. For now, we'll just generate one randomly.
const PRIV_KEY = PrivateKey.getRandObj().field;
const PUB_KEY = PublicKey.fromPrivate(new PrivateKey(PRIV_KEY));

// Users can create multiple distinct aliases for each app as long as they all
// have distinct `AliasId`s. An app can limit users to N aliases by only
// permitting proofs that show the `AliasId` is less than N. An ap that wants to
// enforce one account per human can require AliasId to always be 0.
const ALIAS_ID = 0;

// The ZoKrates proof doesn't allow for function parameters of unknown length,
// so we need to tell it the maximum number of steps in the Merkle proof. This
// binds the maximum size of the tree to 2 ** MERKLE_TREE_MAX_DEPTH. This
// parameter needs to be kept in sync with the N in MerkleProofStep[N] on the
// ZoKrates side.
const MERKLE_TREE_MAX_DEPTH = 24;

// Conversion and serialization helpers
const bufferToBigInt = (buffer) => toBigIntBE(buffer);
const bigIntToBuffer = (bigInt) => toBufferBE(bigInt, 32);
const bufferToZok64 = (buffer) =>
  buffer
    .toString("hex")
    .split(/(.{16})/)
    .filter((c) => c.length > 0)
    .map((chunk) => parseInt(chunk, 16).toString());
const bufferToZokField = (buffer) => "0x" + bufferToBigInt(buffer).toString(16);
const numToZok = (num) => "0x" + num.toString(16);
const stringToNum = (str) => bufferToBigInt(Buffer.from(str));

// Adapt the poseidon hash function to work with `merkletreejs`.
const treePoseidon = (input) => {
  const lhs = input.slice(0, input.length / 2);
  const rhs = input.slice(input.length / 2, input.length);
  return bigIntToBuffer(poseidon([bufferToBigInt(lhs), bufferToBigInt(rhs)]));
};

// The app token is a persistent ID derived from your FixedID and the app you're
// signing into. Since it doesn't depend on your public key, it allows for
// transparent account recovery.
const appToken = poseidon([FIXED_ID, stringToNum(APP_ID), stringToNum(PASSWORD), ALIAS_ID]);

const hashedPassword = poseidon([stringToNum(PASSWORD)]);

// This leaf will live in the Merkle tree of active users maintained by a smart
// contract. Everything in it is public knowledge.
const pubKeyCombined = BigInt(PUB_KEY.p.x.n.plus(PUB_KEY.p.y.n).toFixed());
const myLeaf = bigIntToBuffer(poseidon([FIXED_ID, pubKeyCombined, hashedPassword]));

// Fill out the rest of our Merkle tree with random hashes. In reality, this would be
// the hashes of all other users' leaves.
console.log("Generating placeholder leaves");
const leaves = range(50000).map((x) => bigIntToBuffer(poseidon([x])));

// Insert my own leaf into the list of leaves
leaves[1000] = myLeaf;
console.log("Generating the tree");
const tree = new MerkleTree(leaves, treePoseidon);

console.log("Generating Merkle proof");
let merkleProof = tree.getProof(myLeaf).map((step) => ({
  isRightNode: step.position === "right",
  otherDigest: bufferToZokField(step.data),
}));
if (merkleProof.length > MERKLE_TREE_MAX_DEPTH) {
  throw `Error: tree is larger than MERKLE_TREE_MAX_DEPTH permits (${
    tree.getLeaves().length
  } > 2 ** ${MERKLE_TREE_MAX_DEPTH})`;
} else if (merkleProof.length < MERKLE_TREE_MAX_DEPTH) {
  // Dummy proof steps to pad out the `merkleProof` array to the expected length.
  merkleProof = merkleProof.concat(
    Array(MERKLE_TREE_MAX_DEPTH - merkleProof.length).fill({
      isRightNode: true,
      otherDigest: "0",
    })
  );
}

async function main() {
  const zok = await initialize();

  const source = (await fs.promises.readFile(path.join(__dirname, "../proof.zok"))).toString();

  console.log("Compiling contract");
  const artifacts = zok.compile(source, { config: { allow_unconstrained_variables: true } });

  console.log("Computing the witness");
  const { witness, output } = zok.computeWitness(artifacts, [
    bufferToZokField(tree.getRoot()),
    numToZok(stringToNum(APP_ID)),
    numToZok(NONCE),
    numToZok(MAX_ALIASES),
    numToZok(appToken),
    [PUB_KEY.p.x.n.toFixed(), PUB_KEY.p.y.n.toFixed()],
    numToZok(FIXED_ID),
    PRIV_KEY.n.toFixed(),
    numToZok(stringToNum(PASSWORD)),
    numToZok(ALIAS_ID),
    merkleProof,
  ]);

  console.log("Valid proof generated");
}

main().catch(console.error);
